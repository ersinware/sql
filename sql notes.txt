-- SQL cümlelerinin hepsi MySQL için yazılmadı, bazı cümleler MySQL için çalışmayabilir

** ABSTRACTION **
	-- physical --> disk
	-- logical  --> relationships
	-- view 		--> hides datatypes, grants
** ABSTRACTION **

** SUPERKEY, CANDIDATE KEY **
	-- SUPER KEY:
		-- bir veya birden fazla özellik bir araya gelerek bir satırı tanımlarsa, bunlar SUPER KEY olarak adlandırılır
		-- örneğin müşterinin adı ve adresi SUPER KEY olabilir, çünkü bu iki özellik o satırı eşsiz yapar
	-- CANDIDATE KEY:
		-- içinde SUPER KEY içermeyen SUPER KEY'dir
		-- mesela müşteri adı, yaşı ve adresi SUPER KEY belirtir ancak adı ve adresi de SUPER KEY belirtir, adı ve adresi SUPER KEY olarak belirtilirse CANDIDATE KEY olur
		-- PRIMARY KEY de CANDIDATE KEY'dir
** SUPERKEY, CANDIDATE KEY **

** VIEW **
	-- view'lar sanal tablolardır, birkaç tablo birleştirilip view haline getirilebilir
	-- bu güvenlik açısından da aynı sorguların tekrar tekrar çalıştırılmaması açısından da önemlidir
	-- kullanıcılara tablolara değil de view'lara erişim izni verilebilir

	-- view'ler başka view'leri kullanarak oluşturulabilir
	-- bir view diğer bir view'e direkt bağlıysa, bağımlılık depend directly'dir
	-- eğer v1 kullanılarak v2 oluşturulmuşsa ve v2 kullanılarak da v3 view'i oluşturulmuşsa :
	-- 		v3 view'inin v1 view'ine bağımlılığı, depend on'dur
	--		v3 view'inin v2 view'ine bağımlılığı, depend directly'dir
	-- eğer bir view kendine bağımlısı ise bağımlılık türü, recursive'dir

	-- view'e insert yaparken normal tabloya yaparmış gibi yapılır(??)
	CREATE VIEW viewname AS <any legal SQL expression>
** VIEW **

** TRANSACTIONS **
	-- veritabanı verileri hemen diske yazmaz veya veritabanı üzerinde yapılan 
	-- değişiklikler hemen diske uygulanmaz. Önce RAM'de tutulur
	-- diske yazılması işlemi, commit work'tür. her commit work için bir iz bırakılır
	-- ve rollback work ile commit work geri alınabilir
	-- eğer commit work'ten önce başka birisi ilgili verilere ulaşmak isterse, 
	-- commit work otomatik gerçekleşir
	-- commit work otomatik olarak belli bir zaman geçince gerçekleşir
	-- programlama dillerinde ilgili metodlarla bu işlemler yapılabilir
	-- autoCommit özelliği de vardır programlama dillerinde
	-- örneğin çok fazla update yapılan bir veritabanı ise autoCommit özelliğinin
	-- kapalı olmasında fayda var
	-- kritik işlemlerden sonra commit alınması daha makbül
** TRANSACTIONS **

** INTEGRITY CONSTRAINTS ON A SINGLE RELATION **
	-- not null
	-- primary key - null olamaz - yalnız bir sütun -ya da birden fazla sütunun birleşimi- primary key olabilir
	-- foreign key 
	-- unique - bir defaya mahsus null olabilir - birden fazla unique column olabilir
	-- check(P) - bu ne?
** INTEGRITY CONSTRAINTS ON A SINGLE RELATION **

** INDEXES **
	-- PRIMARY KEY için otomatik index oluşturulur

	-- index ile verilere daha hızlı erişilebilir, dosya yapısını buna göre organize eder

	CREATE INDEX id_index on tableName(id)
		-- manuel index oluşturma
** INDEXES **

** USER-DEFINED TYPES **
	CREATE TYPE TURKISHLIRA AS NUMERIC(12,2) FINAL
		-- artık CREATE TABLE cümlesinde TURKISHLIRA tipinde sütun tanımlanabilir
** USER-DEFINED TYPES **

** DOMAINS **
	-- anlamadım, öğren ve not al
** DOMAINS **

** LARGE OBJECT TYPES **
	-- veritabanları videoları, resimleri vb. şeyleri dosya sisteminden daha sağlıklı tutabiliyor
	-- örneğin bir dosyanın path'ini veritabanına kaydetmektense dosyayı binary olarak kaydetmek 
	-- daha iyi
	-- photos, videos, ...
	-- BLOB > binary large object - binary olarak tutar
	-- CLOB > character large object
	-- veritabanında 10 gb'lık video olabilir, tamamının ram'de tutulmaması için stream'ler üzerinden
	-- veri akışı sağlanabilir
	-- STREAM NEDİR? ÖĞREN VE NOT AL
** LARGE OBJECT TYPES **

** AUTHORIZATION **
	-- YETKİLER > read, insert, update, delete (tablo üzerindeki işlemler)
	-- YETKİLER > index tanımlama, resources(yeni tablolar oluşturma)
	-- YETKİLER > alteration(alter komutları), drop(tabloyu silme)

	-- all privileges > tüm yetkiler
	GRANT <privilege list (read, insert, update, delete)>
	ON <relation name or view name> 
	TO <user list>

	GRANT SELECT ON tableName TO <user list>
		-- okuma yetkisi verme

	REVOKE <privilege list>
	ON <relation name or view name >
	FROM <user list>
** AUTHORIZATION **

** ROLES **
	-- veritabanı yetkileri için roller tanımlanabilir
	-- örneğin programcı rolü, veritabanı yedekçisi rolü, ...
	-- tablo yerine view de kullanılabilir

	CREATE ROLE roleName
		-- rol oluşturma
	GRANT SELECT ON tableName TO roleName
		-- role yetki verildi
** ROLES **

** ODBC **
	-- Open Database Connectivity standard
	-- hemen hemen tüm veritabanları destekler
	-- bağlantı teknolojisidir
	-- veritabanı üreticileri ile programlama dilleri üreticileri arasındaki
	-- ortak bir protokol gibi
	-- en kötü ve yavaş teknolojidir
** ODBC **

** PROCEDURES AND FUNCTIONS **
	-- ATOMIC keyword'ünün ne anlama geldiğini ve ne işe yaradığını öğren, not al
	-- bir yapısal programlama dilinde 3 özellik olmalı :
	-- fonksiyonlar, koşullar, döngüler
	-- SQL de bunların hepsi var

	-- bazı veritabanları table-valued functions barındırır
	-- yani fonksiyonlar tablo döndürebilir

	-- functions
	-- her seferinde query'ler ile uğraşılmadan fonksiyonlar çağırılır, normal methodlar gibi

	-- fonksiyon yazma
	CREATE FUNCTION getDeptCount(deptName VARCHAR(20)) RETURNS INTEGER
	BEGIN
	DECLARE count INTEGER;
	SELECT COUNT(*) INTO count FROM instructor -- dönen sonuç count değişkenine atılıyor
	WHERE instructor.deptName = deptName
	RETURN count;
	END

	-- fonksiyon çağırma
	SELECT deptName, budget FROM department
	WHERE getDeptCount(deptName) > 1

	-- tablo döndüren fonksiyon yazma
	CREATE FUNCTION getInstructors(deptName CHAR(20)) 
	RETURNS TABLE (id INT(11), name VARCHAR(20), deptName VARCHAR(20), salary NUMERIC(8,2))
	BEGIN
	RETURN TABLE (SELECT id, name, deptName, salary FROM instructor WHERE instructor.deptName = deptName)
	END

	-- tablo döndüren fonksiyon çağırma
	SELECT * FROM TABLE (getInstructors('music'))

	-- procedure yazmak
	CREATE PROCEDURE getDeptCount(IN deptName VARCHAR(20), OUT count INT)
	BEGIN
	SELECT COUNT INTO count FROM instructor
	WHERE instructor.deptName = deptName
	END

	-- procedure çağırmak
	DECLARE count INT 				-- bu değişkenin içine procedure'den dönen değer atılır
	CALL getDeptCount("Pyhsics", count);
	-- procedure'lerde overloading de olabilir

	-- while döngüsü
	CREATE PROCEDURE procedureName ()
	BEGIN
	DECLARE n INT DEFAULT 0;
	WHILE n < 10 DO
		SET n = n + 1
	END WHILE
	END

	-- repeat döngüsü (repeat = do while)
	CREATE PROCEDURE procedureName ()
	BEGIN
	DECLARE n INT DEFAULT 0;
	REPEAT
		SET n = n - 1
		UNTIL n = 0
	END REPEAT
	END

	-- for döngüsü
	CREATE PROCEDURE procedureName ()
	BEGIN
	DECLARE n INT DEFAULT 0; -- n toplam bütçedir
	FOR r AS -- r her kayıttaki budget değeridir (her kayıt için döner)
		SELECT budget FROM department WHERE deptName = 'Music'
	DO
		SET n = n + r.budget
	END FOR
	END
** PROCEDURES AND FUNCTIONS **

** TRIGGERS **
	-- belli bir işlem tamamlandığında tetiklenen fonksiyonlardır

	-- account tablosuna herhangi bir kayıt eklenmeden önce çalışır
	CREATE TRIGGER triggerName BEFORE INSERT ON account
	  FOR EACH ROW SET @sum = @sum + NEW.amount; -- NEW yeni eklenen kayıttır

	 -- triggering event can be insert, delete or update
	 -- referencing old row as > for deletes and updates
	 -- referencing new row as > for inserts and updates

	 CREATE TRIGGER setNullTrigger BEFORE UPDATE ON takes
	 REFERENCING NEW ROW AS nRow
	 FOR EACH ROW 
	 	WHEN(nRow.grade = ' ')
	 		BEGIN ATOMIC
	 			SET nRow.grade = null
	 		END
** TRIGGERS **

******************************************* 
  DATA DEFINITION & MANIPULATION LANGUAGE   
*******************************************

USE databaseName; 
	-- veritabanı sunucusundaki veritabanlarının birisine bağlanmak için kullanılır

DESC databaseName.tableName;
	-- veritabanındaki tablo bilgilerini döndürür

DELETE FROM tableName WHERE specificColumnName = data;

DROP TABLE tableName;
	-- tablo siler

** CREATE **
	CREATE TABLE tableName (
		columnName1 DATA_TYPE(MAX SIZE) XXX, 
		columnName2 DATA_TYPE(MAX SIZE) XXX,
		...
		... 	
	);
	-- XXX --> DEFAULT <VALUE> | NOT NULL | AUTO_INCREMENT | ...

	CREATE TABLE IF NOT EXISTS tableName (
		...
		...
	);
** CREATE **

** INSERT ** 
	INSERT INTO <any legal SQL expression>
		-- bir query'den dönen sonuçların hepsi de kayıt edilebilir - tek insert sorgusu ile

	INSERT INTO tableName (columnName1, columnName2, ...) 
	VALUES 
	('data1', 'data2', ...), 
	('data1', 'data2', ...);

	INSERT INTO tableName (columnName1, columnName2, ...) 
	VALUES ('data1', 'data2', ...), ('data1', 'data2', ...)
	ON DUPLICATE KEY UPDATE columnName1 = data;
		-- eğer columnName1 = data koşulu sağlanırsa güncelleme yapar, sağlanmazsa ekleme yapar
** INSERT ** 

** CONCAT **
	SELECT CONCAT_WS(" ", name, surname) AS nameAndSurname FROM users
	-- iki sütunu tek sütunmuş gibi döndürür
	-- ilk parametre, verilerin arasına getirilecek olan string'tir

	SELECT columnName1, columnName2, CONCAT(name, " ", surname) AS nameAndSurname FROM users

	SELECT 
	CONCAT(name, " ", surname) AS nameAndSurname, 
	CONCAT(country, " ", city) AS address
	FROM users

	SELECT *, CONCAT(name, " ", surname) AS nameAndSurname FROM users
** CONCAT **

** UPDATE **
	UPDATE tableName SET updatingColumnName = updatedData, updatingColumnName2 = updatedData2 
	WHERE specificColumnName = data2;

	UPDATE tableName SET columnName1 = REPLACE(columName1, 'e', '!');
		-- columnName1'deki tüm 'e'leri, '!' yapar
		-- devamı da yazılabilir, normal UPDATE sorgusu gibi

	INSERT INTO tableName (columnName1, columnName2, ...) 
	VALUES ('data1', 'data2', ...), ('data1', 'data2', ...)
	ON DUPLICATE KEY UPDATE columnName1 = data;
		-- eğer columnName1 = data koşulu sağlanırsa güncelleme yapar, sağlanmazsa ekleme yapar
** UPDATE **

** ALTER **
	ALTER TABLE tableName ADD COLUMN newColumnName DATA_TYPE(SIZE) XXX;
		-- XXX > NOT NULL, DEFAULT gibi diğer komutlar yazılabilir
		-- tabloya yeni bir sütun ekler

	ALTER TABLE tableName ADD COLUMN newColumnName DATA_TYPE(SIZE) XX specificColumnName;
	-- XX > AFTER | BEFORE
	-- specificColumnName'den önce veya sonraya ekler (sıra olarak)

	ALTER TABLE tableName DROP COLUMN droppingColumnName
		-- tablodan sütun siler

	ALTER TABLE tableName ADD PRIMARY KEY(columnName);
		-- ilgili sütunu birincil anahtar yapar

	ALTER TABLE tableName DROP PRIMARY KEY;
		-- tablodaki birincil anahtarı kaldırır

	ALTER TABLE tableName CHANGE oldColumnName newColumnName DATA_TYPE(SIZE) AUTO_INCREMENT;
		-- var olan sütunun özelliklerini değiştirmek

	ALTER TABLE oldColumnName RENAME newColumnName;
** ALTER **

** ALIAS **
	SELECT columnName AS newColumnName FROM tableName AS newTableName;

	SELECT satışFiyatı * adet AS sermaye FROM tableName ORDER BY sermaye DESC;	
	 -- satışFiyatı ve adet'i çarpıp, sermayeyi hesaplar ve sermayeye göre büyükten küçüğe olacak şekilde döndürür

	SELECT *, SUM(id) AS total FROM tableName
		-- yalnızca bir satır döndürür, ek olarak satıra 'total' sütununu ekler ve tüm satırların id'lerinin
		-- toplamı bu 'total' sütununda yazar

	SELECT *, 'data' AS newColumnName FROM tableName
		-- tüm satırları döndürür ve ek olarak newColumnName adında bir sütun ekler, bu sütundaki veri her
		-- satır için 'data'dır
** ALIAS **

** PRIMARY KEY, UNIQUE, FOREIGN KEY **
	CREATE TABLE tableName (
		columnName1 DATA_TYPE(MAX SIZE) XXX, 
		columnName2 DATA_TYPE(MAX SIZE) XXX,
		...
		... 
		parentId INT NOT NULL
		-- columnName1 tekrar edebilir, diğerleri de ancak hepsinin 
		-- birden tekrar ettiği bir kayıt olamaz!	
		PRIMARY KEY(columName1, columnName2, ...),
		UNIQUE(columName1, columName2)
		FOREIGN KEY (parentId) 
			REFERENCES parentTable(id)
			ON UPDATE XXX, ON DELETE XXX 
			-- XXX > RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT
	);
** PRIMARY KEY, UNIQUE, FOREIGN KEY **

** DISTINCT **
	SELECT DISTINCT * FROM tableName;
		-- tekrarlı kayıtları getirmez

	SELECT COUNT(DISTINCT columnName) FROM tableName;
		-- columnName'deki tekrarsız kayıtların sayısını döndürür

	SELECT ALL * FROM tableName;
		-- tekrar eden kayıtları da döndürür
** DISTINCT **

** SELF INTEGRITY **
	CREATE TABLE person (
		...
		...
		name CHAR(10)
		mother CHAR(10),
		father CHAR(10),
		...
		...
		FOREIGN KEY (mother) 
			REFERENCES person(mother)
			ON UPDATE XXX, ON DELETE XXX 
		FOREIGN KEY (father) 
			REFERENCES person(father)
			ON UPDATE XXX, ON DELETE XXX 
	);
	-- mother ve father sütununda yer alan veriler, person tablosundaki verilerden biri olmalıdır
	-- tabloda hiç kayıt yokken sıkıntı doğacağından, ilk başta değerler null olabilir
	-- ilk veriler kaydedildikten sonra ALTER komutu ile FOREIGN KEY de eklenebilir
** SELF INTEGRITY **

** CHECK **
	CREATE TABLE section {
		...
		...
		semester VARCHAR(6),
		..
		..
		CHECK(semester IN ('Fall', 'Winter', 'Spring', 'Summer'))
		-- semester sütununa IN'den sonra belirtilen küme elemanlarından birisi yazılabilir yalnızca
	};
** CHECK **

** NULL **
	SELECT columName1, columnName2, ... FROM tableName WHERE specificColumnName IS NULL;
		-- null olanları döndürür
	-- null ile yapılan tüm işlemler null döner
	-- null > 5 --> null döner
	-- not null --> null
	-- null or true --> true
	-- null or false --> null
	-- null and true --> null
	-- null and false --> false 
** NULL **

** WHERE **
	SELECT columName1, columnName2, ... FROM tableName WHERE specificColumnName = data;

	SELECT columName1, columnName2, ... FROM tableName WHERE id < 5;

	SELECT columName1, columnName2, ... FROM tableName WHERE condition1 AND condition2 AND condition3 AND ...;

	SELECT columName1, columnName2, ... FROM tableName WHERE condition1 OR condition2 OR condition3 OR ...;

	SELECT columName1, columnName2, ... FROM tableName WHERE (condition1 OR condition2) AND condition3;			

	SELECT columName1, columnName2, ... FROM tableName WHERE NOT condition;
		-- koşulu sağlayanları döndürmez

	SELECT columName1, columnName2, ... FROM tableName WHERE condition1 AND NOT condition2; 
		-- condition1'i sağlayanları, condition2'yi sağlamayanları döndürür		

	SELECT * FROM tableName WHERE columnName IS NULL
		-- null olanları döndürür
			
	SELECT * FROM tableName WHERE columnName IS NOT NULL
		-- null olmayanları döndürür

	SELECT * FROM tableName WHERE columnName BETWEEN 10 AND 20
			
	SELECT * FROM tableName WHERE columnName >=10 AND columnName columName <= 20
		-- 10 ile 20 arasındakileri getirir
		-- alt ve üst sınır dahildir
		-- sayısal sütunlar, tarih ve zaman için kullanılır
		-- NOT ile de kullanılabilir
** WHERE **	

** LIKE **
	SELECT * FROM tableName WHERE columnName LIKE 'php'
		-- bu ifade eşittir >  SELECT * FROM tableName WHERE columnName = 'php'
		-- LIKE'ın başına NOT da getirilebilir > NOT LIKE

	SELECT * FROM tableName WHERE columnName LIKE 'php%'
		-- başında php olanları döndürür

	SELECT * FROM tableName WHERE columnName LIKE '%php'
		-- sonunda php olanları döndürür

	SELECT * FROM tableName WHERE columnName LIKE '%php%'
		-- herhangi bir kısmında php barındıranları döndürür

	SELECT * FROM tableName WHERE columnName LIKE 'p_m'
		-- 'p' ile başlayıp da 'm' ile bitenleri döndürür ancak '_' karakteri aradaki karakter sayısını belirtir
		-- örneğin 'pim' diye bir kayıt varsa döndürür
		-- p___m yazılsaydı eğer, 'piiim' kaydını döndürürdü
** LIKE **

** IN **
	SELECT * FROM tableName WHERE birinciKüme IN ikinciKüme
		-- eğer birinciKüme, ikinciKüme'nin alt kümesi olan satırları döndürür

	SELECT columName1, columnName2, ... FROM tableName WHERE columnName IN ('data1', 'data2', ...);
		-- IN komutundan sonra yazılan kümenin herhangi bir elemanına eşit olan satırları döndürür
		-- OR kullanımı ile aynı
		-- WHERE columnName = 'data1' OR 'data2' OR ...

	SELECT columName1, columnName2, ... FROM tableName WHERE id IN (1, 2)
		-- id'si 1 veya 2 olanları döndürür

	SELECT * FROM tableName WHERE columName1, columnName2 IN (1, 2)
		-- columnName1'i 1, columnName2'si 2 olanları döndürür

	SELECT columName1, columnName2, ... FROM tableName WHERE id NOT IN (1, 2)
		-- id'si 1 veya 2 olmayanları döndürür
** IN **

** LIMIT ** 
	SELECT columName1, columnName2, ... FROM tableName LIMIT 1
		-- ilk satırı döndürür

	SELECT columName1, columnName2, ... FROM tableName LIMIT 2
		-- ilk 2 satırı döndürür

	SELECT columName1, columnName2, ... FROM tableName LIMIT 0, 5
		-- alt sınır dahil, üst sınır dahil olmamak üzere satırları indis numarasına göre döndürür
		-- örneğin, 0, 1, 2, 3, 4. indise sahip satırları döndürür

	SELECT columName1, columnName2, ... FROM tableName WHERE condition LIMIT 1;
** LIMIT ** 

** ORDER BY **
	SELECT * FROM tableName ORDER BY columnName;
		-- columnName'e göre sıralı bir şekilde verileri döndürür
		-- string'leri de sıralar

	SELECT * FROM tableName ORDER BY columnName1 ASC, columnName2 DESC;
		-- önce columnName1'e göre sıralar eğer, columnName1'deki veriler eşitse columnName2'ye göre sıralar

	SELECT * FROM tableName ORDER BY FIELD (columnName, data1, data2, data3);
		-- data1 = 10 için, columnName'i 10 olan veriler önce döndürülür

	SELECT satışFiyatı * adet AS sermaye FROM tableName ORDER BY sermaye DESC;
		-- satışFiyatı ve adet'i çarpıp, sermayeyi hesaplar ve sermayeye göre büyükten küçüğe olacak şekilde döndürür

	SELECT columName1, columnName2, ... FROM tableName WHERE condition ORDER BY columnName XXX LIMIT 3
		-- XXX > ASC (artan) | DESC (azalan) - default olarak ASC'dir	
** ORDER BY **

** JOIN **
	SELECT * FROM tableName1, tableName2
		-- iki tablonun kartezyen çarpımını döndürür (join)
		-- ilk önce birinci tablonun ilk satırı ile ikinci tablonun tüm satırlarını tek tek döndürür
		-- birinci tablonun tüm satırları için aynı işlem tekrarlanır

	SELECT * FROM tableName1, tableName2 WHERE tableName1.id = tableName2.id;
		-- INNER JOIN olarak geçer
		-- 2 tabloyu tek bir tabloymuş gibi döndürür
		-- yani iki tablodaki tüm sütunları eklediği bir tablo gibi olur
		-- İKİDEN FAZLA TABLO İÇİN DE YAPILABİLİR

	SELECT * FROM tableName1 INNER JOIN tableName2 ON tableName1.id = tableName2.id
		-- yukarıdaki cümle ile aynıdır

	SELECT tableName1.* FROM tableName1 INNER JOIN tableName2 ON tableName1.id = tableName2.id
		-- sadece tableName1'deki kısıtı sağlayan satırları döndürür

	SELECT * FROM tableName1 LEFT JOIN tableName2 ON tableName1.parentId = tableName2.id 
	WHERE tableName1.specificColumnName = data
		-- OUTER LEFT JOIN olarak geçer
		-- soldaki tablonun tüm satırlarını döndürür ancak sağdaki tablonun yalnızca eşleşen satırlarını döndürür 
		-- tek bir tabloymuş gibi döndürür
		-- RIGHT JOIN yazılmış olsaydı ise, sağdaki tablonun tüm satırlarını döndürürdü ancak soldaki tablonun 
		-- yalnızca eşleşen satırlarını döndürürdü

	SELECT * FROM tableName1 AS t1 LEFT JOIN tableName2 AS t2 ON t1.parentId = t2.id 
	WHERE t1.specificColumnName = data
		-- ALIAS ile bu şekilde kullanılabilir

	SELECT * FROM tableName1 AS t1 LEFT JOIN tableName2 AS t2 ON t1.parentId = t2.id 
	WHERE t1.specificColumnName = data ORDER BY t1.specificColumnName2 DESC LIMIT 5
		-- cümle bu şekilde genişletilebilir

	SELECT * FROM tableName1 LEFT JOIN tableName2 ON tableName1.parentId = tableName2.id 
	UNION
	SELECT * FROM tableName1 RIGHT JOIN tableName2 ON tableName1.parentId = tableName2.id
		-- FULL OUTER JOIN olarak geçer
		-- UNION komutu iki kümenin birleşimini döndürür, kümede tekrarlı eleman olmaz, her satır 1 kez döndürülür
		-- iki tablodaki eşleşen tüm satırlar ve iki tablodaki eşleşmeyen tüm satırlar döndürülür
** JOIN **

** GROUP BY **
	-- belirtilen sütuna göre gruplar ve her gruptaki veriler için aggregate fonksiyonlar
	-- çalıştırma imkanı verir

	SELECT * FROM tableName GROUP BY columnName
		-- columnName'de tekrarlı kayıt varsa yalnızca birisini döndürür

	SELECT * FROM tableName GROUP BY columnName ORDER BY columnName2 DESC
		-- ORDER BY ile de kullanılabilir

	SELECT * FROM tableName WHERE condition GROUP BY specificColumnName ORDER BY specificColumnName2 DESC
		-- WHERE ile de kullanılabilir
		-- önce WHERE kısıtı işler, sonra GROUP BY sonra ORDER BY

	SELECT SUM(id) FROM tableName GROUP BY columnName
		-- columnName'i aynı olan satırların id'sini toplar, bir satır olarak döndürür
		-- diğer satırların ise yalnızca id'sini döndürür

	SELECT *, SUM(id) AS total FROM tableName GROUP BY columnName
		-- columnName'i aynı olan satırlardan yalnızca birisini döndürür ve total sütununda
		-- bu aynı satırların id'lerinin toplamı yazar
		-- diğer satırların ise yalnızca id'sini döndürür
** GROUP BY **	

** HAVING **
	SELECT SUM(id) AS total FROM tableName GROUP BY columnName HAVING total > 3
		-- columnName'i aynı olan satırlardan yalnızca birisini döndürür ve total sütununda
		-- bu aynı satırların id'lerinin toplamı yazar
		-- diğer satırların ise yalnızca id'sini döndürür
		-- tüm bunlara ek olarak total'i 3'ten büyük olanları döndürür

	SELECT SUM(id) AS total FROM tableName GROUP BY columnName HAVING total BETWEEN 3 AND 6
		-- columnName column'u için id'leri toplamı 3 ile 6 dahil olmak üzere 3 ile 6 arasındakileri döndürür
		-- diğer column'lar için ise id'si 3 ile 6 dahil olmak üzere 3 ile 6 arasındakileri döndürür

	-- ... HAVING condition
	-- GROUP BY'dan sonra WHERE sorgusu yazılamaz ancak HAVING ile bu işlem gerçekleştirilebilir
	-- yani grupladırdıktan sonra HAVING kısıtı işler
** HAVING **

** SUBQUERY, UNION, INTERSECT, EXCEPT, UNIQUE, NOT UNIQUE, WITH **
	SELECT topicName FROM topics WHERE userId IN (SELECT id FROM users WHERE age > 15)
		-- topics, users > tablo isimleri
		-- topicName, userId, topics; id ve age ise users tablosunun sütunları
		-- kullanıcılar (users), konu(topic) açabiliyor - topic tablosundaki userId FOREIGN KEY
		-- bu sorgu, yaşı 15'ten büyük olan kullanıcıların açtığı konuların isimlerini döndürür
		-- SUBQUERY olarak geçer

	SELECT id, name FROM tableName1
	UNION
	SELECT id, name FROM tableName2
	ORDER BY id DESC
		-- UNION komutu iki kümenin birleşimini döndürür, kümede tekrarlı eleman olmaz, her satır 1 kez döndürülür
		-- iki tablodaki tüm satırlar, id ve name sütunları ile ALT ALTA - JOIN ile farkı bu -  döndürülür

	SELECT id, name FROM tableName1
	INTERSECT
	SELECT id, name FROM tableName2
	ORDER BY id DESC
		-- kesişimlerini alır

	SELECT id, name FROM tableName1
	EXCEPT
	SELECT id, name FROM tableName2
	ORDER BY id DESC
		-- fark işlemi yapar

	* NOT UNIQUE ve UNIQUE kullanımını araştır *
	* WITH kullanımını araştır *
** SUBQUERY, UNION, INTERSECT, EXCEPT, UNIQUE, NOT UNIQUE, WITH **

** DEFINED FUNCTIONS **
	SELECT LAST_INSERT_ID();

	SELECT MIN(columnName) FROM tableName;

	SELECT MAX(columnName) FROM tableName;

	SELECT COUNT(*) FROM tableName;

	SELECT AVG(columnName) FROM tableName;
		-- verilerin ortalamasını döndürür

	SELECT SUM(columnName) FROM tableName;
		-- verilerin toplamını döndürür

	SELECT MOD(37, 13);
		-- mod alır

	SELECT ABS(-4);	
		-- mutlak değer alır

	SELECT SIGN(number);
		-- eğer sayı negatif ise -1 döndürür
		-- eğer sayı pozitif ise 1 döndürür
		-- eğer sayı sıfır ise 0 döndürür

	SELECT POWER(2, 4);
		-- sayının üssünü alır

	SELECT SQRT(16);
		-- karekök alır

	SELECT ROUND(11.7);
		-- sayıyı yuvarlar
		-- 11.5'ten küçükse 11'e, 11.5'ten büyükse 12'ye yuvarlar

	SELECT FLOOR(11.9);
		-- ondalık kısmı atar, yani 11 döndürür
** DEFINED FUNCTIONS **

** CONDITIONS **
	SELECT
	CASE
		WHEN id = 0 THEN 'Kadın'
		WHEN id = 1 THEN 'Erkek'
		ELSE 'Diğer' 
	END 
	AS cinsiyet
	FROM mytable;

	SELECT IF(condition, "true", "false") AS newColumnName;
** CONDITIONS **

** REGEXP **
	SELECT columnName FROM tableName WHERE columName REGEXP '^ers'
		-- 'ers' ile başlayanları döndürür

	SELECT columnName FROM tableName WHERE columName REGEXP 'ers$'
		-- 'ers' ile bitenleri döndürür

	SELECT columnName FROM tableName WHERE columName REGEXP 'ers'
		-- içinde 'ers' bulunanları döndürür
** REGEXP **

** SOME, ALL **
	SELECT * FROM tableName WHERE columName > SOME (küme)
		-- eğer columnName, kümenin içindeki herhangi bir elemandan daha büyük ise satırı döndürür
		-- küme = {0, 1, 2, 3, 4} ve columnName = 1, 2, 3, 4 için --> satırı döndürür
		-- columnName = 0 için --> satırı döndürmez

	SELECT * FROM tableName WHERE columName > ALL (küme)
		-- eğer columnName, kümenin içindeki her elemandan daha büyük ise satırı döndürür
** SOME, ALL **